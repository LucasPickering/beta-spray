type Query {
  boulders(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): BoulderNodeConnection
  boulder(
    """The ID of the object"""
    id: ID!
  ): BoulderNode
  problems(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): ProblemNodeConnection
  problem(
    """The ID of the object"""
    id: ID!
  ): ProblemNode
  beta(
    """The ID of the object"""
    id: ID!
  ): BetaNode
}

type BoulderNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BoulderNodeEdge!]!
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A Relay edge containing a `BoulderNode` and its cursor."""
type BoulderNodeEdge {
  """The item at the end of the edge"""
  node: BoulderNode!

  """A cursor for use in pagination"""
  cursor: String!
}

type BoulderNode implements Node {
  createdAt: DateTime!
  holds(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): HoldNodeConnection!
  problems(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): ProblemNodeConnection!

  """The ID of the object"""
  id: ID!
  image: Image!
}

"""An object with an ID"""
interface Node {
  """The ID of the object"""
  id: ID!
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

type HoldNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [HoldNodeEdge!]!
}

"""A Relay edge containing a `HoldNode` and its cursor."""
type HoldNodeEdge {
  """The item at the end of the edge"""
  node: HoldNode!

  """A cursor for use in pagination"""
  cursor: String!
}

type HoldNode implements Node {
  boulder: BoulderNode!

  """Left-to-right position of the hold within the image, 0-1"""
  positionX: Float!

  """Top-to-bottom position of the hold within the image, 0-1"""
  positionY: Float!

  """The ID of the object"""
  id: ID!
}

type ProblemNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ProblemNodeEdge!]!
}

"""A Relay edge containing a `ProblemNode` and its cursor."""
type ProblemNodeEdge {
  """The item at the end of the edge"""
  node: ProblemNode!

  """A cursor for use in pagination"""
  cursor: String!
}

type ProblemNode implements Node {
  name: String!
  holds(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): HoldNodeConnection!
  boulder: BoulderNode!
  createdAt: DateTime!
  betas(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): BetaNodeConnection!

  """The ID of the object"""
  id: ID!
}

type BetaNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BetaNodeEdge!]!
}

"""A Relay edge containing a `BetaNode` and its cursor."""
type BetaNodeEdge {
  """The item at the end of the edge"""
  node: BetaNode!

  """A cursor for use in pagination"""
  cursor: String!
}

type BetaNode implements Node {
  name: String!
  problem: ProblemNode!
  createdAt: DateTime!
  moves(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): BetaMoveNodeConnection!

  """The ID of the object"""
  id: ID!
}

type BetaMoveNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BetaMoveNodeEdge!]!
}

"""A Relay edge containing a `BetaMoveNode` and its cursor."""
type BetaMoveNodeEdge {
  """The item at the end of the edge"""
  node: BetaMoveNode!

  """A cursor for use in pagination"""
  cursor: String!
}

type BetaMoveNode implements Node {
  beta: BetaNode!

  """Optional destination hold for this move"""
  hold: HoldNode

  """Ordering number of the hold in the beta, starting at 1"""
  order: Int!

  """The ID of the object"""
  id: ID!

  """Body part being moved"""
  bodyPart: BodyPart!

  """Is this one of the initial moves for the beta?"""
  isStart: Boolean!
}

"""A body part that someone could put on a hold"""
enum BodyPart {
  LEFT_HAND
  RIGHT_HAND
  LEFT_FOOT
  RIGHT_FOOT
}

"""An image, e.g. JPG or PNG"""
type Image {
  url: String!
  width: Int!
  height: Int!
}

type Mutation {
  createBoulder(input: CreateBoulderMutationInput!): CreateBoulderMutationPayload

  """
  Add a hold to a boulder. Optionally, also bind the hold to a pre-existing
  problem.
  """
  createHold(input: CreateHoldMutationInput!): CreateHoldMutationPayload

  """Modify an existing hold"""
  updateHold(input: UpdateHoldMutationInput!): UpdateHoldMutationPayload

  """Delete a hold from a boulder"""
  deleteHold(input: DeleteHoldMutationInput!): DeleteHoldMutationPayload

  """
  Create a new problem for a specific boulder. You can either specify an
  existing boulder, or attach a new image to create a boulder (but not both).
  """
  createProblem(input: CreateProblemMutationInput!): CreateProblemMutationPayload
  updateProblem(input: UpdateProblemMutationInput!): UpdateProblemMutationPayload
  deleteProblem(input: DeleteProblemMutationInput!): DeleteProblemMutationPayload

  """Add a hold to a problem"""
  createProblemHold(input: CreateProblemHoldMutationInput!): CreateProblemHoldMutationPayload

  """Remove a hold from a problem"""
  deleteProblemHold(input: DeleteProblemHoldMutationInput!): DeleteProblemHoldMutationPayload
  createBeta(input: CreateBetaMutationInput!): CreateBetaMutationPayload
  updateBeta(input: UpdateBetaMutationInput!): UpdateBetaMutationPayload
  copyBeta(input: CopyBetaMutationInput!): CopyBetaMutationPayload
  deleteBeta(input: DeleteBetaMutationInput!): DeleteBetaMutationPayload

  """
  Add a new move to an existing beta. A move can optionally be associated with
  a hold. Some moves (flagging, smearing, etc.) do not need an associated hold
  though.
  
  If a move already exists for the given order+beta combo, the new move will
  be given the requested order, and every other move in the beta will "slide
  down", e.g. if the new move is `order=3`, then the existing move #3 will
  become #4, #4 will become #5, etc.
  
  If no order is given, the move will be appended to the end.
  """
  createBetaMove(input: CreateBetaMoveMutationInput!): CreateBetaMoveMutationPayload
  updateBetaMove(input: UpdateBetaMoveMutationInput!): UpdateBetaMoveMutationPayload
  deleteBetaMove(input: DeleteBetaMoveMutationInput!): DeleteBetaMoveMutationPayload
}

type CreateBoulderMutationPayload {
  boulder: BoulderNode!
  clientMutationId: String
}

input CreateBoulderMutationInput {
  imageFile: String!
  clientMutationId: String
}

"""
Add a hold to a boulder. Optionally, also bind the hold to a pre-existing
problem.
"""
type CreateHoldMutationPayload {
  hold: HoldNode!
  problem: ProblemNode
  clientMutationId: String
}

input CreateHoldMutationInput {
  boulderId: ID!
  positionX: Float!
  positionY: Float!
  problemId: ID
  clientMutationId: String
}

"""Modify an existing hold"""
type UpdateHoldMutationPayload {
  hold: HoldNode!
  clientMutationId: String
}

input UpdateHoldMutationInput {
  holdId: ID!
  positionX: Float
  positionY: Float
  clientMutationId: String
}

"""Delete a hold from a boulder"""
type DeleteHoldMutationPayload {
  hold: HoldNode!
  clientMutationId: String
}

input DeleteHoldMutationInput {
  holdId: ID!
  clientMutationId: String
}

"""
Create a new problem for a specific boulder. You can either specify an
existing boulder, or attach a new image to create a boulder (but not both).
"""
type CreateProblemMutationPayload {
  problem: ProblemNode!
  clientMutationId: String
}

input CreateProblemMutationInput {
  name: String
  boulderId: ID
  imageFile: String
  clientMutationId: String
}

type UpdateProblemMutationPayload {
  problem: ProblemNode!
  clientMutationId: String
}

input UpdateProblemMutationInput {
  problemId: ID!
  name: String
  clientMutationId: String
}

type DeleteProblemMutationPayload {
  problem: ProblemNode!
  clientMutationId: String
}

input DeleteProblemMutationInput {
  problemId: ID!
  clientMutationId: String
}

"""Add a hold to a problem"""
type CreateProblemHoldMutationPayload {
  problem: ProblemNode!
  hold: HoldNode!
  clientMutationId: String
}

input CreateProblemHoldMutationInput {
  problemId: ID!
  holdId: ID!
  clientMutationId: String
}

"""Remove a hold from a problem"""
type DeleteProblemHoldMutationPayload {
  problem: ProblemNode!
  hold: HoldNode!
  clientMutationId: String
}

input DeleteProblemHoldMutationInput {
  problemId: ID!
  holdId: ID!
  clientMutationId: String
}

type CreateBetaMutationPayload {
  beta: BetaNode!
  clientMutationId: String
}

input CreateBetaMutationInput {
  problemId: ID!
  name: String
  clientMutationId: String
}

type UpdateBetaMutationPayload {
  beta: BetaNode!
  clientMutationId: String
}

input UpdateBetaMutationInput {
  betaId: ID!
  name: String
  clientMutationId: String
}

type CopyBetaMutationPayload {
  beta: BetaNode!
  clientMutationId: String
}

input CopyBetaMutationInput {
  betaId: ID!
  clientMutationId: String
}

type DeleteBetaMutationPayload {
  beta: BetaNode!
  clientMutationId: String
}

input DeleteBetaMutationInput {
  betaId: ID!
  clientMutationId: String
}

"""
Add a new move to an existing beta. A move can optionally be associated with
a hold. Some moves (flagging, smearing, etc.) do not need an associated hold
though.

If a move already exists for the given order+beta combo, the new move will
be given the requested order, and every other move in the beta will "slide
down", e.g. if the new move is `order=3`, then the existing move #3 will
become #4, #4 will become #5, etc.

If no order is given, the move will be appended to the end.
"""
type CreateBetaMoveMutationPayload {
  betaMove: BetaMoveNode!
  beta: BetaNode!
  clientMutationId: String
}

input CreateBetaMoveMutationInput {
  betaId: ID!
  bodyPart: BodyPart!
  order: Int
  holdId: ID
  clientMutationId: String
}

type UpdateBetaMoveMutationPayload {
  betaMove: BetaMoveNode!
  clientMutationId: String
}

input UpdateBetaMoveMutationInput {
  betaMoveId: ID!
  order: Int
  holdId: ID
  clientMutationId: String
}

type DeleteBetaMoveMutationPayload {
  betaMove: BetaMoveNode!
  clientMutationId: String
}

input DeleteBetaMoveMutationInput {
  betaMoveId: ID!
  clientMutationId: String
}
