"""
A singular move within a beta, which is a body part+location pairing. This
may be confusing because a "move" can also refer to the motion of a body
part from point A to point B, but in the context of this API, a move
always refers to a particular body part in a particular position.

Most moves are attached to a particular hold, but not all. For example,
flagging a leg or smearing a foot will apply to a general area on the
boulder rather than a particular hold.
"""
type BetaMoveNode implements Node {
  id: ID!

  """Date+time of object creation"""
  createdAt: DateTime!
  beta: BetaNode!

  """Body part being moved"""
  bodyPart: BodyPart!

  """The ordering of this move within the beta, starting at 1"""
  order: Int!

  """Is this one of the initial moves for the beta?"""
  isStart: Boolean!

  """Informative text related to the move, created by the user"""
  annotation: String!

  """
  The optional hold that this move is attached to. If null, the move is 'free', e.g. a flag or smear.
  """
  hold: HoldNode

  """Position of a free move. Null for attached moves."""
  position: SVGPosition
}

"""A connection to a list of items."""
type BetaMoveNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [BetaMoveNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type BetaMoveNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: BetaMoveNode!
}

"""
A beta is a sequence of moves that solves a problem. The word is really used
as a mass known so the phrase "a beta" is actually incorrect, but treating
it as a singular noun makes the verbiage much easier in code.
"""
type BetaNode implements Node {
  id: ID!

  """User-friendly name of the beta"""
  name: String!

  """Date+time of object creation"""
  createdAt: DateTime!
  owner: UserNode!
  problem: ProblemNode!
  moves(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): BetaMoveNodeConnection!
}

"""A connection to a list of items."""
type BetaNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [BetaNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type BetaNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: BetaNode!
}

"""A body part that someone could put on a hold"""
enum BodyPart {
  LEFT_HAND
  RIGHT_HAND
  LEFT_FOOT
  RIGHT_FOOT
}

"""
A boulder is a wall or rock that has holds on it. In the context of this
API, a boulder is defined by a 2D raster image of it. The holds are then
defined in X/Y coordinates, in reference to the image.
"""
type BoulderNode implements Node {
  id: ID!

  """Date+time of object creation"""
  createdAt: DateTime!
  image: Image!
  problems(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): ProblemNodeConnection!
  holds(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): HoldNodeConnection!
}

"""A connection to a list of items."""
type BoulderNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [BoulderNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type BoulderNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: BoulderNode!
}

"""Input data for `copyBeta` mutation"""
input CopyBetaInput {
  id: ID!
}

"""Input data for `createBeta` mutation"""
input CreateBetaInput {
  problem: ID!
}

"""Input data for `createBetaMove` mutation"""
input CreateBetaMoveInput {
  beta: ID!
  bodyPart: BodyPart!
  hold: ID
  position: SVGPositionInput
  previousBetaMove: ID
}

"""Input data for `createBoulderWithFriends` mutation"""
input CreateBoulderWithFriendsInput {
  image: ImageUpload!
}

"""Input data for `createHold` mutation"""
input CreateHoldInput {
  """
  The ID of the problem to add the hold to. If the ID references a boulder, then the hold will be created on that boulder. If a problem is given, it will be added to the problem's parent boulder as well as the problem itself.
  """
  problem: ID!
  position: SVGPositionInput
}

"""Date with time (isoformat)"""
scalar DateTime

"""
A hold is a particular point on a boulder that can be grabbed or otherwise
used by a climber.
"""
type HoldNode implements Node {
  id: ID!
  boulder: BoulderNode!

  """Date+time of object creation"""
  createdAt: DateTime!

  """Informative text related to the hold, created by the user"""
  annotation: String!

  """Position of the hold within the boulder image"""
  position: SVGPosition!
}

"""A connection to a list of items."""
type HoldNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [HoldNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type HoldNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: HoldNode!
}

"""An image, e.g. JPG or PNG"""
type Image {
  """Image access URL"""
  url: String!

  """Image width, in pixels"""
  width: Int!

  """Image height, in pixels"""
  height: Int!

  """
  Image width, either `100` if portrait or `width/height*100` if landscape
  """
  svgWidth: Float!

  """
  Image height, either `100` if landscape or `height/width*100` if
  portrait
  """
  svgHeight: Float!
}

"""
An uploaded image. To upload a file, see: https://strawberry.rocks/docs/guides/file-upload#sending-file-upload-requests
"""
scalar ImageUpload

type Mutation {
  deleteHold(
    """Input of an object that implements the `Node` interface."""
    input: NodeInput!
  ): HoldNode!
  updateProblem(input: UpdateProblemInput!): ProblemNode!
  deleteProblem(
    """Input of an object that implements the `Node` interface."""
    input: NodeInput!
  ): ProblemNode!
  updateBeta(input: UpdateBetaInput!): BetaNode!
  deleteBeta(
    """Input of an object that implements the `Node` interface."""
    input: NodeInput!
  ): BetaNode!
  deleteBetaMove(
    """Input of an object that implements the `Node` interface."""
    input: NodeInput!
  ): BetaMoveNode!

  """
  Create a new boulder from an image, and create a default problem and
  beta along with it.
  
  Returns the created beta, which can be used to grab the created problem
  and boulder as well (via nested objects).
  """
  createBoulderWithFriends(
    """Input data for `createBoulderWithFriends` mutation"""
    input: CreateBoulderWithFriendsInput!
  ): BetaNode!

  """
  Create a new hold and add it to a problem. There is no option to create
  a hold just on a boulder, because there's no use case for that yet.
  """
  createHold(
    """Input data for `createHold` mutation"""
    input: CreateHoldInput!
  ): HoldNode!
  updateHold(
    """Input data for `updateHold` mutation"""
    input: UpdateHoldInput!
  ): HoldNode!
  createBeta(
    """Input data for `createBeta` mutation"""
    input: CreateBetaInput!
  ): BetaNode!
  copyBeta(
    """Input data for `copyBeta` mutation"""
    input: CopyBetaInput!
  ): BetaNode!

  """
  Add a new move to a beta. The move can either be appended to the end,
  or inserted in the middle (by specifying a previousBetaMove).
  """
  createBetaMove(
    """Input data for `createBetaMove` mutation"""
    input: CreateBetaMoveInput!
  ): BetaMoveNode!
  updateBetaMove(
    """Input data for `updateBetaMove` mutation"""
    input: UpdateBetaMoveInput!
  ): BetaMoveNode!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  id: ID!
}

"""Input of an object that implements the `Node` interface."""
input NodeInput {
  id: ID!
}

"""Information to aid in pagination."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""
A "problem" is a boulder route. It consists of a series of holds on a
boulder.
"""
type ProblemNode implements Node {
  id: ID!

  """User-friendly name of the problem"""
  name: String!

  """External link, e.g. to Mountain Project"""
  externalLink: String!

  """Date+time of object creation"""
  createdAt: DateTime!
  owner: UserNode!

  """Access level for other users to this problem"""
  visibility: Visibility!
  boulder: BoulderNode!
  holds(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): HoldNodeConnection!
  betas(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): BetaNodeConnection!
}

"""A connection to a list of items."""
type ProblemNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ProblemNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type ProblemNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: ProblemNode!
}

type Query {
  """Access boulders by list"""
  boulders(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): BoulderNodeConnection!

  """Get a boulder by ID"""
  boulder(
    """The ID of the object."""
    id: ID!
  ): BoulderNode

  """Access problems by list"""
  problems(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): ProblemNodeConnection!

  """Get a problem by ID"""
  problem(
    """The ID of the object."""
    id: ID!
  ): ProblemNode

  """Get a beta by ID"""
  beta(
    """The ID of the object."""
    id: ID!
  ): BetaNode

  """
  Get data on the requesting user (you). Unautheticated users will have a
  guest account created.
  """
  currentUser: UserNode!
}

"""
A 2D position in an image, in the terms that the UI uses. The bounds of the
coordinates are:
    - `[0, 100]` in the smaller of the two dimensions
    - `[0, 100 * width / height]` or `[0, 100 * height / width]`

The origin is the top-left, with X increasing to the right and Y increasing
down.

The purpose of this system is to provide normalized width and height so that
UI elements can be sized statically without having to worry about varying
image resolutions.
"""
type SVGPosition {
  """X position, 0-100ish"""
  x: Float!

  """Y position, 0-100ish"""
  y: Float!
}

input SVGPositionInput {
  """X position, 0-100ish"""
  x: Float!

  """Y position, 0-100ish"""
  y: Float!
}

input UpdateBetaInput {
  id: ID!
  name: String
}

"""Input data for `updateBetaMove` mutation"""
input UpdateBetaMoveInput {
  id: ID!
  order: Int
  hold: ID
  position: SVGPositionInput
  annotation: String
}

"""Input data for `updateHold` mutation"""
input UpdateHoldInput {
  id: ID!
  position: SVGPositionInput
  annotation: String
}

input UpdateProblemInput {
  id: ID!
  name: String

  """External link, e.g. to Mountain Project"""
  externalLink: String

  """Access level for other users to this problem"""
  visibility: Visibility
}

"""A user of Beta Spray"""
type UserNode implements Node {
  id: ID!

  """Username"""
  username: String!

  """
  Is this user a guest? True if the user has not created an account. Only
  exposed to self.
  """
  isGuest: Boolean!
}

"""Visibility of an object within the platform, i.e. who else can see it?"""
enum Visibility {
  PRIVATE
  UNLISTED
  PUBLIC
}