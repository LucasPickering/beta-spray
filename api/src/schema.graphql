"""
If unauthenticated, a guest user will be created for you when calling this mutation.
"""
directive @createGuestUser on FIELD_DEFINITION

"""
Will check if the user has any/all permissions for the resolved value of this field before returning it.

When the condition fails, the following can happen (following this priority):
1) If the return value can return an `OperationMessage`, it is returned as that type.
2) If the field is mandatory (e.g. `String!`), this will result in an error.
3) If the field is not mandatory and a list (e.g. `[String]`), an empty list will be returned.
4) If the field is not mandatory and any scalar or object (e.g. `String`), `null` will be returned.
5) If the field is a relay `Connection`, an empty connection will be returned.
"""
directive @hasObjPerm(permissions: [PermDefinition!]!, any: Boolean! = true) on FIELD_DEFINITION

"""
A singular move within a beta, which is a body part+location pairing. This
may be confusing because a "move" can also refer to the motion of a body
part from point A to point B, but in the context of this API, a move
always refers to a particular body part in a particular position.

Most moves are attached to a particular hold, but not all. For example,
flagging a leg or smearing a foot will apply to a general area on the
boulder rather than a particular hold.
"""
type BetaMoveNode implements Node {
  id: ID!

  """Date+time of object creation"""
  createdAt: DateTime!
  beta: BetaNode!

  """Body part being moved"""
  bodyPart: BodyPart!

  """The ordering of this move within the beta, starting at 1"""
  order: Int!

  """Is this one of the initial moves for the beta?"""
  isStart: Boolean!

  """Informative text related to the move, created by the user"""
  annotation: String!

  """
  The optional hold that this move is attached to. If null, the move is 'free', e.g. a flag or smear.
  """
  hold: HoldNode

  """
  Permissions for the requesting user (you) on the parent object.
  Attempting any mutation that you don't have permission for will result
  in an error.
  """
  permissions: Permissions!

  """Position of a free move. Null for attached moves."""
  position: SVGPosition
}

"""A connection to a list of items."""
type BetaMoveNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [BetaMoveNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type BetaMoveNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: BetaMoveNode!
}

"""
A beta is a sequence of moves that solves a problem. The word is really used
as a mass known so the phrase "a beta" is actually incorrect, but treating
it as a singular noun makes the verbiage much easier in code.
"""
type BetaNode implements Node {
  id: ID!

  """User-friendly name of the beta"""
  name: String!

  """Date+time of object creation"""
  createdAt: DateTime!
  owner: UserNode!
  problem: ProblemNode!
  moves(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): BetaMoveNodeConnection!

  """
  Permissions for the requesting user (you) on the parent object.
  Attempting any mutation that you don't have permission for will result
  in an error.
  """
  permissions: Permissions!
}

"""A connection to a list of items."""
type BetaNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [BetaNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type BetaNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: BetaNode!
}

"""A body part that someone could put on a hold"""
enum BodyPart {
  LEFT_HAND
  RIGHT_HAND
  LEFT_FOOT
  RIGHT_FOOT
}

"""
A boulder is a wall or rock that has holds on it. In the context of this
API, a boulder is defined by a 2D raster image of it. The holds are then
defined in X/Y coordinates, in reference to the image.
"""
type BoulderNode implements Node {
  id: ID!

  """Date+time of object creation"""
  createdAt: DateTime!
  image: Image!
  problems(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): ProblemNodeConnection!
  holds(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): HoldNodeConnection!

  """
  Permissions for the requesting user (you) on the parent object.
  Attempting any mutation that you don't have permission for will result
  in an error.
  """
  permissions: Permissions!
}

"""A connection to a list of items."""
type BoulderNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [BoulderNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type BoulderNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: BoulderNode!
}

"""Input data for `copyBeta` mutation"""
input CopyBetaInput {
  id: ID!
}

"""Input data for `createBeta` mutation"""
input CreateBetaInput {
  problem: ID!
}

"""Input data for `createBetaMove` mutation"""
input CreateBetaMoveInput {
  beta: ID!
  bodyPart: BodyPart!
  hold: ID
  position: SVGPositionInput
  previousBetaMove: ID
}

"""Input data for `createBoulderWithFriends` mutation"""
input CreateBoulderWithFriendsInput {
  image: ImageUpload!
}

"""Input data for `createHold` mutation"""
input CreateHoldInput {
  """The ID of the problem to add the hold to."""
  problem: ID!
  position: SVGPositionInput
}

"""Date with time (isoformat)"""
scalar DateTime

"""
A hold is a particular point on a boulder that can be grabbed or otherwise
used by a climber.
"""
type HoldNode implements Node {
  id: ID!
  problem: ProblemNode!

  """Date+time of object creation"""
  createdAt: DateTime!

  """Informative text related to the hold, created by the user"""
  annotation: String!

  """
  Permissions for the requesting user (you) on the parent object.
  Attempting any mutation that you don't have permission for will result
  in an error.
  """
  permissions: Permissions!

  """Position of the hold within the boulder image"""
  position: SVGPosition!
}

"""A connection to a list of items."""
type HoldNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [HoldNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type HoldNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: HoldNode!
}

"""An image, e.g. JPG or PNG"""
type Image {
  """Image access URL"""
  url: String!

  """Image width, in pixels"""
  width: Int!

  """Image height, in pixels"""
  height: Int!

  """
  Image width, either `100` if portrait or `width/height*100` if landscape
  """
  svgWidth: Float!

  """
  Image height, either `100` if landscape or `height/width*100` if
  portrait
  """
  svgHeight: Float!
}

"""
An uploaded image. To upload a file, see: https://strawberry.rocks/docs/guides/file-upload#sending-file-upload-requests
"""
scalar ImageUpload

type Mutation {
  updateUser(input: UpdateUserInput!): UserNode! @hasObjPerm(permissions: [{resource: "auth", permission: "edit_user"}], any: true)
  deleteHold(
    """Input of an object that implements the `Node` interface."""
    input: NodeInput!
  ): HoldNode! @hasObjPerm(permissions: [{resource: "core", permission: "delete_hold"}], any: true)
  updateProblem(input: UpdateProblemInput!): ProblemNode! @hasObjPerm(permissions: [{resource: "core", permission: "edit_problem"}], any: true)
  deleteProblem(
    """Input of an object that implements the `Node` interface."""
    input: NodeInput!
  ): ProblemNode! @hasObjPerm(permissions: [{resource: "core", permission: "delete_problem"}], any: true)
  updateBeta(input: UpdateBetaInput!): BetaNode! @hasObjPerm(permissions: [{resource: "core", permission: "edit_beta"}], any: true)
  deleteBeta(
    """Input of an object that implements the `Node` interface."""
    input: NodeInput!
  ): BetaNode! @hasObjPerm(permissions: [{resource: "core", permission: "delete_beta"}], any: true)
  deleteBetaMove(
    """Input of an object that implements the `Node` interface."""
    input: NodeInput!
  ): BetaMoveNode! @hasObjPerm(permissions: [{resource: "core", permission: "delete_betamove"}], any: true)

  """Log out the current user (if any)"""
  logOut: Void

  """
  Create a new boulder from an image, and create a default problem and
  beta along with it.
  
  Returns the created beta, which can be used to grab the created problem
  and boulder as well (via nested objects).
  """
  createBoulderWithFriends(
    """Input data for `createBoulderWithFriends` mutation"""
    input: CreateBoulderWithFriendsInput!
  ): BetaNode! @createGuestUser

  """
  Create a new hold and add it to a problem. There is no option to create
  a hold just on a boulder, because there's no use case for that yet.
  """
  createHold(
    """Input data for `createHold` mutation"""
    input: CreateHoldInput!
  ): HoldNode! @hasObjPerm(permissions: [{resource: "core", permission: "create_hold"}], any: true)
  updateHold(
    """Input data for `updateHold` mutation"""
    input: UpdateHoldInput!
  ): HoldNode! @hasObjPerm(permissions: [{resource: "core", permission: "edit_hold"}], any: true)
  createBeta(
    """Input data for `createBeta` mutation"""
    input: CreateBetaInput!
  ): BetaNode! @createGuestUser
  copyBeta(
    """Input data for `copyBeta` mutation"""
    input: CopyBetaInput!
  ): BetaNode! @createGuestUser

  """
  Add a new move to a beta. The move can either be appended to the end,
  or inserted in the middle (by specifying a previousBetaMove).
  """
  createBetaMove(
    """Input data for `createBetaMove` mutation"""
    input: CreateBetaMoveInput!
  ): BetaMoveNode! @hasObjPerm(permissions: [{resource: "core", permission: "create_betamove"}], any: true)
  updateBetaMove(
    """Input data for `updateBetaMove` mutation"""
    input: UpdateBetaMoveInput!
  ): BetaMoveNode! @hasObjPerm(permissions: [{resource: "core", permission: "edit_betamove"}], any: true)
}

"""
An empty object representing an unauthenticated user. This is essentially
a null, but Relay has limitations around store management for null values
(you can't invalidate a null value to force a refetch), so we need to
provide this instead. And you can't have empty types, so we need a
placeholder field.
"""
type NoUser {
  ignore: String!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  id: ID!
}

"""Input of an object that implements the `Node` interface."""
input NodeInput {
  id: ID!
}

"""Information to aid in pagination."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""Permission info for the requesting user on the parent object."""
type Permissions {
  """Can you edit this object?"""
  canEdit: Boolean!

  """Can you delete this object?"""
  canDelete: Boolean!
}

"""
A "problem" is a boulder route. It consists of a series of holds on a
boulder.
"""
type ProblemNode implements Node {
  id: ID!

  """User-friendly name of the problem"""
  name: String!

  """External link, e.g. to Mountain Project"""
  externalLink: String!

  """Date+time of object creation"""
  createdAt: DateTime!
  owner: UserNode!

  """Access level for other users to this problem"""
  visibility: Visibility!
  boulder: BoulderNode!
  holds(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): HoldNodeConnection!
  betas(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): BetaNodeConnection!

  """
  Permissions for the requesting user (you) on the parent object.
  Attempting any mutation that you don't have permission for will result
  in an error.
  """
  permissions: Permissions!
}

"""A connection to a list of items."""
type ProblemNodeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ProblemNodeEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type ProblemNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: ProblemNode!
}

type Query {
  """Access boulders by list"""
  boulders(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): BoulderNodeConnection!

  """Get a boulder by ID"""
  boulder(
    """The ID of the object."""
    id: ID!
  ): BoulderNode

  """Access problems by list"""
  problems(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): ProblemNodeConnection!

  """Get a problem by ID"""
  problem(
    """The ID of the object."""
    id: ID!
  ): ProblemNode

  """Get a beta by ID"""
  beta(
    """The ID of the object."""
    id: ID!
  ): BetaNode

  """
  Get data on the requesting user (you). Null for unauthenticated users.
  Unauthenticated users who have performed a mutation will be logged in
  as a guest user.
  """
  currentUser: UserNodeNoUser!
}

"""
A 2D position in an image, in the terms that the UI uses. The bounds of the
coordinates are:
    - `[0, 100]` in the smaller of the two dimensions
    - `[0, 100 * width / height]` or `[0, 100 * height / width]`

The origin is the top-left, with X increasing to the right and Y increasing
down.

The purpose of this system is to provide normalized width and height so that
UI elements can be sized statically without having to worry about varying
image resolutions.
"""
type SVGPosition {
  """X position, 0-100ish"""
  x: Float!

  """Y position, 0-100ish"""
  y: Float!
}

input SVGPositionInput {
  """X position, 0-100ish"""
  x: Float!

  """Y position, 0-100ish"""
  y: Float!
}

input UpdateBetaInput {
  id: ID!
  name: String
}

"""Input data for `updateBetaMove` mutation"""
input UpdateBetaMoveInput {
  id: ID!
  order: Int
  hold: ID
  position: SVGPositionInput
  annotation: String
}

"""Input data for `updateHold` mutation"""
input UpdateHoldInput {
  id: ID!
  position: SVGPositionInput
  annotation: String
}

input UpdateProblemInput {
  id: ID!
  name: String

  """External link, e.g. to Mountain Project"""
  externalLink: String

  """Access level for other users to this problem"""
  visibility: Visibility
}

input UpdateUserInput {
  id: ID!

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String
}

"""A user of Beta Spray"""
type UserNode implements Node {
  id: ID!

  """Username"""
  username: String!

  """Is this the authenticated user? False if unauthenticated."""
  isCurrentUser: Boolean!

  """
  Is this user a guest? True if the user has not created an account. Only
  exposed to self.
  """
  isGuest: Boolean!
}

union UserNodeNoUser = UserNode | NoUser

"""Visibility of an object within the platform, i.e. who else can see it?"""
enum Visibility {
  UNLISTED
  PUBLIC
}

"""Represents NULL values"""
scalar Void

"""Permission definition for schema directives."""
input PermDefinition {
  resource: String
  permission: String
}